---
title: Paxos算法和Raft
date: 2020-02-19 17:37:26
thumbnail: 
categories:
    - 算法
tags:
    - 分布式
---


## Paxos算法

&emsp;&emsp;在分布式应用中，应用通常会部署多个实例，每个实例具有相同的功能，并且经常都会操作共同的数据，所以最常见的一个问题就是如何在分布式系统中保证数据的一致性。在保证一致性的同时，系统的可用性又要如何考虑？

<!-- more -->
首先这些保证分布式系统一致性的算法也是有一个演化的过程的，对数据一致性的要求也是从强一致性（ACID）向最终一致性转化（BASE）；

### 2PC

2阶段提交， 特点就是有一个事务的协调器，那么它带来的问题就是单点问题，因为所有的一致性的确认操作，都要通过事务协调器来完成；

1. 准备阶段

事务协调者向所有的事务参与者发送事务内容，等待参与者的返回确认，参与者执行事务（但不提交，将事务计入日志），然后将执行的结果返回给事务的协调者；

2. 提交阶段

当协调者收到所有的参与者的ok信息，则向所有的参与者发送提交事务请求，参与者收到消息后提交事务并回复提交成功的ack，正常的流程结束；
但是如果某一个参与者的事务执行结果返回的是失败的，或者是协调者在等待超时后没有收到所有的参与者的反馈，那么就会向所有的参与者发送回滚事务的请求，收到请求的所有的参与者回滚事务后，返回信息给协调者。

从上面的操作中可以看出，2pc存在着许多的问题：
1. 同步阻塞和单点问题
所有的操作都通过事务协调器完成，并且事务协调器需要阻塞等待所有的参与者都回复信息；
2. 数据不一致
第二阶段的操作中，如果一阶段的所有参与者都返回成功，二阶段的提交请求由于网络的原因可能并不是所有的参与者都收到了提交请求；

大多的主流数据库系统都支持了2pc协议，但是讲道理目前来说使用的并不多；由于2pc的局限性，提出了3pc来改进2pc；

#### 3PC

3pc即在2pc的2个阶段的中间加了一个阶段，预提交阶段，意在防止在2pc中，网络或者是其他原因导致提交阶段的请求部分的参与者没有收到，导致部分的参与者没能顺利提交事务。
首先和2pc一样，先准备，然后第二步发起预提交（第一步顺利的情况下），参与者收到预提交请求，给协调者返回成功收到，然后这时并没有执行事务，协调者收到所有参与者的成功收到预提交回复后，最后发起提交请求，然后所有的参与着再提交事务。
那么它如何防止部分参与者不能顺利提交的呢？在预提交的时候，参与者并不提交，而是等到协调者的第三步的指令，但是如果迟迟没有收到第三部的指令，那么参与者就自行将事务提交；

虽然多保证了一些的数据的一致性，但是3pc对2pc的优化个人感觉不多。2pc中存在的问题3pc中依旧存在，只不过数据不一致的可能性降低，参与者被阻塞的可能性减小；于是又使用到Paxos算法来优化；


#### Paxos

它的基础是所有的信息都是可信的，也就是不存在拜占庭将军问题；
然后是少数服从多数（半数以上的节点）；

paxos算法带来了一个比较重量级的优化，干掉了比较会成为瓶颈的事务协调者，解决了单点的问题；
它是一个被证明的共识算法（已经用了这么久了），其实也是基于2阶段提交的扩展，其中有三种节点：
1. proposer： 提案的提出者（类似于执行事务的动作的发起者，客户端）
2. acceptor： 提案的接收者（服务端收到提出者的提案并进行投票）
3. leaner：   只接收提案的最终结果，不参与投票
