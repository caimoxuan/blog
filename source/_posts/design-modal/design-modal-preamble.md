---
title: 设计模式-入门篇
date: 2019-10-20 20:57:16
thumbnail: /gallery/thumbnail/design_modal.jpg
categories:
    - 架构之路
tags:
    - 设计模式
---
&emsp;&emsp;设计模式，不仅仅存在与编码的过程中，更是存在于架构设计，系统交互设计，也存在于生活，可以简单的入门，但想要驾驭的得心应手，确是不是一件简单的事。
&emsp;&emsp;其实在编程中，也许有些设计模式之前并没有了解过，但是其实已经会用了，看别人的代码，本就是一种最简单的学习，先会用，然后在理解，这就是我这样的实用主义的学习方式。

<!-- more -->

# 设计模式-入门概念

## 设计模式的六大原则

### 单一职责

> &emsp;&emsp;简单的说就是一个类只做一件事情。
&emsp;&emsp;在一个java项目中，往往有许多的java工具类，工具类往往提供一系列的静态方法完成某种功能： 处理时间、 处理加密、 处理验签加签等等；个人认为这也是六大原则中最好理解，也是最应该遵守的一个原则。
&emsp;&emsp;这样的原则也体现在微服务中，微服务将复杂的系统纵向拆分，每个服务处理的业务将会变得简化和单一。
&emsp;&emsp;其次这样的原则也体现在前端架构上，目前流行的前端组件化框架，编写组件完成特定的功能，如时间选择器、分页table、form表单等等。
&emsp;&emsp;这个原则，可以说对应用程序来说没有害处，个人觉得这是开发人员必须要遵守的。

### 开闭原则

> &emsp;&emsp;这是六大原则中另一个容易的原则（容易的放一起），如果你不遵守他，那么我觉得这样的项目不久就会陷入重构。
&emsp;&emsp;他告诉我们在编程中应该注意，如果代码中的一些功能正在被使用，那么你最好不要再不知道他的功能或者不知道如何使用它的时候随意的修改它，如果现有的方法不能满足你的需求，可以添加自己想要的方法。
&emsp;&emsp;随意修改正在使用的方法会造成什么隐患也不用多说了，特别需要注意类似mybatis中的sql，这是比较容易范的错误，想要按你的条件来查询，现有的sql不能满足的情况下自己添加select，不要随意的修改别的。记得去年有个新闻，外国有个程序员老用git push -f 来提交代码， 被同事一枪崩了... 就是因为提交代码不是追加的方式，而是覆盖。这确实让人恼怒，但这样也太激动了。少改别人的代码，除非你是接替的项目，想要什么，就添加，毕竟甩锅要有理有据，而且还要为了自己的生命安全着想。


### 里氏替换

>&emsp;&emsp;先说说我对这个原则的理解： 它告诉我，不要随意的重写父类的方法，因为这样可能会造成一些不想看到的结果，和一些未知的隐患，java是可继承的，提提供了多态的同时，也带来了一定的入侵性。
&emsp;&emsp;它的特点是有一个基类Father，基类有2个子类Child1和Child2，Father 对象 f使用的地方，现在如果替换成了Child1的对象，不会影响他的功能，同样要是替换成了Child2的对象，也不会影响功能。而如果随意的重写基类的方法，这样的替换竟会造成功能的改变；
&emsp;&emsp;想要在运用大量多态的同时，尽量减小出错的机率，就需要遵守里氏替换：
>>子类可以扩展基类的方法（功能），但是尽量不要重写父类原有的已实现方法；
子类可以重写父类中的抽象方法，但不要重写非抽象方法；
子列可以增加自己的方法；
子类在重写或实现基类的方法的时候，方法的入参可以比基类更宽松（能做基类的参数方法参数，一定能做子类方法的参数， 反过来可以不一定），比如基类一个方法的参数接受一个类User作为参数，子类重写的时候可以将参数放大为Object类型；
子类在重写或实现基类方法的时候，返回值可以比基类更严格（子类方法的返回值一定能做基类的返回值，反过来可以不一定），比如基类方法的返回值为User类对象，那么子类的返回值可以缩小为User类的子类Admin；
放大和缩小不仅仅体现在类关系上，数值大小等也是需要考虑的，代码写多了就会发现，许多的业务本身就是遵循这些原则的。

### 依赖倒置

>&emsp;&emsp;高层模块不应该依赖底层模块，都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；
&emsp;&emsp;读起来确实是有点拗口，但是一定要多读几遍。理解了其实它的意思很简单。
``` java
 public class A {
     public void test(B b){
         b.do();
     }
 }
```
>&emsp;&emsp;此时A依赖了B，但是此时，A变成想要依赖C，就需要修改A中的依赖来完成。这时换一种思路，添加一个接口I，B、C都实现I，A依赖I，这时实现上面的修改，并不需要修改A，只需要在使用A的时候将依赖修改成C就行了；面向接口编程，更加灵活的处理依赖耦合的问题。



### 接口隔离

> &emsp;&emsp;依赖倒置告诉我们要合理的利用面向接口编程，但是它没有告诉我们，如何合理的设计接口。
&emsp;&emsp;接口的定义中都是方法的声明，虽然现在可以在接口中定义default方法，但是编码规约建议少使用这个特性。实现类如果要实现接口，就必须实现接口中的所有的方法，如果接口中的方法定义的太多，太过杂乱，实现类就需要实现一堆不相关的接口，我觉的稍有一些代码洁癖的编程者都不会希望这样吧。接口中的方法也需要分类，也应该遵循单一职责。
&emsp;&emsp;目前的mvc分层已经演变的相对的规范，接口按业务的功能来划分： 类似AccountService、OrderService等，各自实现自己业务的方法，对自己找方法方便，对其他人也友好。


### 迪米特法则

> &emsp;&emsp;好吧，开始学习的时候常常记不住它的名字...还是喜欢她的另一个名字：最少知道法则。它其实就是告诉我们，在进行依赖的时候，对依赖类知道的尽量的少，只依赖自己直接使用的。我的理解目前的mvc结构中Controller依赖的service、service依赖的dao，可是随着业务的愈加复杂，service依赖dao的结构中的service就会变的很臃肿，大量的业务和数据组合在service中完成，此时可以在service和dao之间加一层manager，让service依赖manager，此时的service就不应该再依赖dao，而是让manager依赖dao。
&emsp;&emsp;这样service并不需要知道dao的功能，只需要注意manager中的功能就好。


### 合成复用原则

>&emsp;&emsp;不是说六大原则，为什么多了一个？在有的地方在介绍设计模式原则的时候，会有一个原则叫合成复用，而会将单一职责给省略，可能是单一制责更像是常识，或者有的干脆介绍为七种原则。合成复用说的是尽量少的使用继承的方式，而是使用组合/聚合的方式。
&emsp;&emsp;但是很少有说明为什么少用继承的，个人理解继承降低了代码的灵活性，父类对子类有着一定的约束，或是子类用了父类的依赖，如果要使用继承，应该是确定子类会用到父类大多数的特性，而自己拥有少部分。其他的情况更应该使用聚合或组合，但凡事无绝对，这之间的道理还需要在实战中慢慢体会，如果不了解组合和聚合，可以先了解他们的区别以及特点，想想spring中的依赖注入或者是一个部门组织架构中的部门类设计。

&emsp;&emsp;脑子总会欺骗你，看完就说它会了，真正遇到问题，脑子睡了，留下你醉了。有的东西可能真的是会的，但是不熟练，需要思考一会才能回忆起来。设计模式说起来就这几个简单的概念，但是实际设计起来却非常的灵活多变，甚至已经上升到了 '禅' 的地步，有本书叫《设计模式之禅》，书的评分不是很高，毕竟书里的东西都是糟粕，真正的东西还是要自己体会，或者是读者很难理解到那样的一个高度，很多东西真的是需要自己体会的。
&emsp;&emsp;但是在编码中个人觉得要注意，千万不要为了套用摸一个模式而把代码变得十分的别扭，什么时候用什么模式，怎么用，是不是优雅了，这些都是要慢慢体会的。而设计模式在现在的使用中，也不仅仅是23种，这不过更多的模式还没有被定义为模式，因为系统是逐渐庞大的，更多的模式将会在实践中被规范。